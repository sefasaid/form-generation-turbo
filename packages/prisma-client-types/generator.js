#!/usr/bin/env node

const { generatorHandler } = require('@prisma/generator-helper');
const fs = require('fs');
const path = require('path');

generatorHandler({
  onManifest() {
    return {
      defaultOutput: './generated',
      prettyName: 'Prisma Client Types',
    };
  },
  async onGenerate(options) {
    const outputDir = options.generator.output?.value || './generated';
    const models = options.dmmf.datamodel.models;
    const enums = options.dmmf.datamodel.enums;

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Generate index file with all exports
    const indexContent = generateIndexFile(models, enums);
    fs.writeFileSync(path.join(outputDir, 'index.ts'), indexContent);

    // Generate individual model files
    for (const model of models) {
      const modelContent = generateModelType(model, models, enums);
      fs.writeFileSync(
        path.join(outputDir, `${model.name}.ts`),
        modelContent
      );
    }

    // Generate enums file
    const enumsContent = generateEnumsFile(enums);
    fs.writeFileSync(path.join(outputDir, 'enums.ts'), enumsContent);
  },
});

function generateIndexFile(models, enums) {
  const modelExports = models.map((m) => `export type { ${m.name} } from './${m.name}';`).join('\n');
  const enumExports = enums.map((e) => `export { ${e.name} } from './enums';`).join('\n');

  return `/**
 * Auto-generated client-side types
 * DO NOT EDIT MANUALLY - This file is generated by @org/prisma-client-types generator
 */

${modelExports}

${enumExports}
`;
}

function generateModelType(model, allModels, enums) {
  // Separate scalar/enum fields from relation fields
  // Relation fields have kind === 'object' or have relationName
  const scalarFields = model.fields.filter((field) => field.kind !== 'object' && !field.relationName);
  const relationFields = model.fields.filter((f) => f.kind === 'object' || f.relationName);

  const fields = scalarFields.map((field) => {
    const optional = field.isRequired ? '' : '?';
    const type = mapPrismaTypeToTypeScript(field, allModels);
    const comment = field.documentation ? `  /** ${field.documentation} */` : '';
    return comment ? `${comment}\n  ${field.name}${optional}: ${type};` : `  ${field.name}${optional}: ${type};`;
  }).join('\n');

  // Generate relation types (optional) and collect imports
  const relationTypes = relationFields.map((field) => {
    const relatedModel = allModels.find((m) => m.name === field.type);
    if (!relatedModel) return '';
    const isArray = field.isList;
    const optional = '?';
    return `  ${field.name}${optional}: ${isArray ? `${relatedModel.name}[]` : relatedModel.name};`;
  }).join('\n');

  // Collect unique related model names for imports (exclude self-referential imports)
  const relatedModelNames = relationFields
    .map((field) => allModels.find((m) => m.name === field.type)?.name)
    .filter((name) => !!name)
    .filter((name) => name !== model.name) // Exclude self-referential imports
    .filter((name, index, arr) => arr.indexOf(name) === index);

  // Collect unique enum names used in fields
  const enumNames = scalarFields
    .filter((field) => field.kind === 'enum')
    .map((field) => field.type)
    .filter((name, index, arr) => arr.indexOf(name) === index);

  const modelImports = relatedModelNames.length > 0
    ? relatedModelNames.map((name) => `import type { ${name} } from './${name}';`).join('\n') + '\n'
    : '';

  const enumImports = enumNames.length > 0
    ? `import { ${enumNames.join(', ')} } from './enums';\n`
    : '';

  const imports = modelImports + enumImports;

  return `/**
 * ${model.name} type for client-side usage
 * Auto-generated from Prisma schema
 * DO NOT EDIT MANUALLY
 */

${imports}export interface ${model.name} {
${fields}
${relationTypes ? '\n' + relationTypes : ''}
}
`;
}

function mapPrismaTypeToTypeScript(field, allModels) {
  // Handle relations
  if (field.relationName) {
    const relatedModel = allModels.find((m) => m.name === field.type);
    if (relatedModel) {
      return field.isList ? `${relatedModel.name}[]` : relatedModel.name;
    }
  }

  // Handle enums
  if (field.kind === 'enum') {
    return field.type;
  }

  // Handle scalar types
  const baseType = (() => {
    switch (field.type) {
      case 'String':
        return 'string';
      case 'Int':
      case 'Float':
        return 'number';
      case 'Boolean':
        return 'boolean';
      case 'DateTime':
        return 'Date | string';
      case 'Json':
        return 'any';
      case 'Bytes':
        return 'Buffer | Uint8Array';
      default:
        // Check if it's a model (shouldn't happen here, but just in case)
        if (allModels.some((m) => m.name === field.type)) {
          return field.type;
        }
        return 'unknown';
    }
  })();

  // Handle array types for scalars
  return field.isList ? `${baseType}[]` : baseType;
}

function generateEnumsFile(enums) {
  const enumDefinitions = enums.map((enumDef) => {
    const values = enumDef.values.map((v) => {
      const comment = v.dbName ? `  /** Database value: ${v.dbName} */` : '';
      return comment ? `${comment}\n  ${v.name} = '${v.name}',` : `  ${v.name} = '${v.name}',`;
    }).join('\n');

    return `/**
 * ${enumDef.name} enum
 * Auto-generated from Prisma schema
 */
export enum ${enumDef.name} {
${values}
}
`;
  }).join('\n\n');

  return `/**
 * Auto-generated enums
 * DO NOT EDIT MANUALLY - This file is generated by @org/prisma-client-types generator
 */

${enumDefinitions}
`;
}
